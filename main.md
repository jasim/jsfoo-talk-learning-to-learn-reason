---
author:
- Jasim A Basheer
subtitle: Thinking with Types
title: Learning to learn ReasonML
titlepage-note: |
  Hello, my name is Jasim, and I'm here today to talk about ReasonML. 
  
  Reason is a Typed Functional programming language, and the types and functions come together in a way that makes better programmers out of ourselves.
  
  I will show you how that happens, and also give you a feel for what it could be to be programming in it on a day-to-day basis. I will also talk about the most efficient way to learn the language, which is based on my experience learning and struggling with it in the past.
  
institute: "@jasim_ab"
fontsize: 17pt
...

## Reason is OCaml

* First released in 1990 in France

* Fast programs approaching C-like speeds

* ISWIM syntax (OCaml, Haskell) not ALGOL (C, Java, Javascript etc.)

::: notes

Reason is a new syntax on top of the OCaml programming language. 

OCaml has a long history - it was first released in 1990 - about 20 years ago. It is a compiled language and produces very performant binaries; it is sort of like GoLang in that respect. 

But its syntax is a little different from most languages that we know.

:::

---

## OCaml sample code

``` {.ocaml}
let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -> accum
  | Some x -> read_and_accumulate (accum +. Float.of_string x)

let () =
  printf "Total: %F\n" (read_and_accumulate 0.)  
```

::: notes

Here is a program that reads a list of numbers from the standard input and prints their sum.

:::

---

## Same code, in Reason

``` {.javascript}
let rec read_and_accumulate = accum => {
  let line = In_channel.input_line(In_channel.stdin);
  switch (line) {
  | None => accum
  | Some(x) => read_and_accumulate(accum +. Float.of_string(x))
  };
};

let () = printf("Total: %F\n", read_and_accumulate(0.));
```

::: notes

Here's the same OCaml code, but in the Reason syntax.

The point is, underneath, it is the same language and same semantics. So I'll use both Reason and OCaml interchangeably in this presentation, depending on what fits the context better.

:::

---

# What can we build with Reason/OCaml?

::: notes

So is it actually useful? This language. What can we build with it? Let me take you through some examples.

:::

---

## What can we build with Reason/OCaml?

### High-frequency trading software

&nbsp;

![](images/jane-street.png)

::: notes

When you start reading about OCaml, you'll often come across Jane Street. They are one of the largest production users of the language and they do billions of dollars worth of trading, all with software written in OCaml.

:::

---

## What can we build with Reason/OCaml?

### World's second largest crawler

&nbsp;

![](images/ahrefs.png)

::: notes

If you have done any SEO work, you might be familiar with Ahrefs. They crawl about 5 million pages every minute, and they have the second largest index just after Google. They use native OCaml for all the back-end infra and for the front-end web they use Reason.

:::

---

## What can we build with Reason/OCaml?

### Compilers

* First version of the Rust compiler
* Flow (typechecker for Javascript)
* Hack (Facebook's PHP compiler)

&nbsp;

::: notes

OCaml is also particularly nice to write compilers on - in fact anything that deals with a lot of tree manipulation is a great fit. Rust borrows many ideas from OCaml, and their first compiler was written in the language. Facebook is also a large user of OCaml internally.

5mins

:::

---

## What can we build with Reason/OCaml?

### Front-end web applications!

* BuckleScript compiles Reason/OCaml to Javascript

::: notes

Those were the traditional applications of OCaml. 

OCaml can also be used to build front-end web applications, and that's what this talk is about.

The regular OCaml compiler emits executable binary, but we want Javascript so it executes on the browser. So there is an OCaml compiler called BuckleScript that emits performant Javascript. And it lets us use any npm library in the OCaml code almost seamlessly.

:::

---

``` {.javascript}
if (MomentRe.Moment.isSameWithGranularity(
      MomentRe.momentNow(),
      MomentRe.moment("2020-04-01"),
      `day,
    )) {
  Js.log("It is the 1st of April!");
} else {
  Js.log("A dreary day");
};
```

::: notes

This Reason code here - it checks whether the current day is April 1st 2020,
and then shows a message.

It uses the momentjs Javascript library from npm. Now let's see how the BuckleScript output looks.

:::

---

``` {.javascript}
// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Moment = require("moment");
var MomentRe = require("bs-moment/src/MomentRe.js");

if (Moment().isSame(MomentRe.moment(undefined, "2020-04-01"), "day")) {
  console.log("It is the 1st of April!");
} else {
  console.log("A dreary day");
}

/*  Not a pure module */
```

::: notes

As you can see BuckleScript required the correct npm module and compiled everything to straightforward Javascript. 

:::

----

## Javascript vs Reason

* **Javascript**: `this`, variable hoisting, prototypes, ES6 classes, objects, mutations, _functions, modules_

* **Reason**: _functions, modules, types_

::: notes
Javascript however is a large language -- it has far too many concepts -- and that is obvious if you've participated in any Javascript interview. You can ask and be asked so many questions. There is the concept of `this`, there is prototypes and prototype inheritance chains which have their own rules, and there are also classes, objects, and mutation. It also has functions and higher-order functions.

Reason comparatively is a smaller language. It only has functions, modules, and types.  We don't, for example, concern ourselves with what `this` could be during runtime. In fact a Reason interview would be a rather unexciting event - there aren't that many quirks to the language to deal with.
:::

---

## Programming in Reason

Two principles:

1) Write pure functions
2) Get their types right

::: notes

The way we program Reason is to write our programs as a series of pure functions. That's it. 

But how is that an improvement over Javascript? We can write Javascript in a similar manner - with pure functions everywhere, and just an outer shell for all the I/O. That's essentially functional programming, and that's pretty nice.

But Reason is not only "functional", it is also "typed", and the types guarantees something:
:::

----

# Perfection

The perfect computer program -- 

::: notes

"perfection".

Reason functions are more "perfect" than functions written in Javascript. The word "perfection" in this context comes from a talk given by Prof. Xavier Leroy, the author of OCaml. 

:::

---

# Perfection

The perfect computer program -- 

> The one that does exactly what it should do, no more, no less, every time, with perfect reliability, and forever. The kind of perfection that you can get from mathematical definitions, which software is to a large extent, or from philosophical concepts.

> -- paraphrased from "In search of software perfection", 2016 Milner Award lecture by Dr. Xavier Leroy, author of OCaml

::: notes

"A perfect function does exactly what it should do, no more, no less, every time, with perfect reliability, and forever. The kind of perfection that you can get from mathematical definitions, which software is to a large extent, or from philosophical concepts."

Let's first try to apply that notion to functions written in Javascript.
::: 

----

## An Imperfect Function

``` {.javascript}
let showNext = lastUser => {
  console.log("You will be user " + (lastUser.id + 1))
}

showNext({id: 16})
```

**_You will be user 17_**

::: notes

Consider this function `showNext` - it tells you what your user id could be, based on the last user in the system. 

The code is as simple as it can get. 

But does it work perfectly reliably all the time, every time?

Will it ever crash in production?

:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: null)
```

::: notes
What if `id` is null?
:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: null)
```

**_You will be user 1_**

::: notes
Thankfully that works. Our function is resilient to nulls.
:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: "193"})
```

::: notes
What if id was a string?
:::

----


## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: "193"})
```

**_You will be user 1931_**

::: notes
That's not what we expected. That's one problem with this function.
:::

---

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({})
```

::: notes
Now what happens when the object is empty?
:::

----


## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({})
```

**_You will be user NaN_**

::: notes
This is also a wrong result. Another way the function is not perfect.
:::

----

## An Imperfect Function


``` {.javascript}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

let users = []
let lastUser = users[users.length - 1]

showNext(lastUser)
```

::: notes
We now have a list of users and we apply the last one to `showNext`. 
Unfortunately, the list is empty. What happens now?
:::

----

## An Imperfect Function



``` {.javascript}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

let users = []
let lastUser = users[users.length - 1]

showNext(lastUser)
```

**_Uncaught TypeError: Cannot read property 'id' of undefined_**

::: notes
The function actually crashes. 

This is a common occurence - we fetch a value from an array or an object -- and it doesn't exist -- so we get a null or an undefined, and then we pass that down to other functions.. and things crash in production. To figure out why, you now have to work backwards and trace the flow of data till we find where it went wrong.
:::

----

## An Imperfect Function


``` {.javascript}
showNext()
showNext({id: "a"})
showNext({id: {}})
showNext(undefined)
showNext(null)
showNext(0)
showNext("a")
showNext([])
showNext([1])
showNext(a => a + 1)
```

::: notes
There are even more ways this function is invalid. None of invokations here would work correctly.
:::

----

## An Imperfect Function


**The Anna Karenina principle**

> All happy families are alike; each unhappy family is unhappy in its own way. 

``` {.javascript}
```

::: notes

There are many ways our function can break. But there is exactly one one way it can succeed. 

And that is 
:::

----

## An Imperfect Function


``` {.javascript}
type user = {

}
```

::: notes
when we pass it an object
:::

----


## An Imperfect Function


``` {.javascript}
type user = {
  id
}
```

::: notes
which has a field `id`
:::

----
## A more perfect function, in Reason

``` {.javascript}
type user = {
  id: int
};
```

::: notes
that is of type integer
:::

----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::

----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::

----

## The cost of Drama


::: notes

Let's build a tiny invoicing program.
It is for a drama troupe.
They put two kinds of plays: Comedies and Tragedies.
:::



---

## First step

``` {.javascript}
switch (play.type) {
  case "tragedy":  
    return new TragedyCalculator(
      aPerformance, aPlay
    );
    
  case "comedy":
    thisAmount = 30000;
    if (perf.audience > 20) {
      thisAmount += 10000 + 500 * (perf.audience - 20);
    }
    thisAmount += 300 * perf.audience;
    break;
  default:
    throw new Error(`unknown type: ${play.type}`);
}
```


---

## Code example

``` {.javascript}
type type_ =
  | Tragedy
  | Comedy;

type play = {
  name: string,
  audience: int,
  type_,
};
```

