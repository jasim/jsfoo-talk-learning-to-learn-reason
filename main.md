---
author:
- Jasim A Basheer
subtitle: Thinking with Types
title: Learning to learn ReasonML
titlepage-note: |
  Hello, my name is Jasim, and I'm here today to talk about ReasonML. 
  
  Reason is a Typed Functional programming language, and the types and functions come together in a way that makes better programmers out of ourselves.
  
  I will show you how that happens, and also give you a feel for what it could be to be programming in it on a day-to-day basis. I will also talk about the most efficient way to learn the language, which is based on my experience learning and struggling with it in the past.
  
institute: "@jasim_ab"
fontsize: 17pt
...

## Reason is OCaml

* First released in 1990 in France

* Fast programs approaching C-like speeds

* ISWIM syntax (OCaml, Haskell) not ALGOL (C, Java, Javascript etc.)

::: notes

Reason is a new syntax on top of the OCaml programming language. 

OCaml has a long history - it was first released in 1990 - about 20 years ago. It is a compiled language and produces very performant binaries; it is sort of like GoLang in that respect. 

But its syntax is a little different from most languages that we know.

:::

---

## OCaml sample code

``` {.ocaml}
let rec read_and_accumulate accum =
  let line = In_channel.input_line In_channel.stdin in
  match line with
  | None -> accum
  | Some x -> read_and_accumulate (accum +. Float.of_string x)

let () =
  printf "Total: %F\n" (read_and_accumulate 0.)  
```

::: notes

Here is a program that reads a list of numbers from the standard input and prints their sum.

:::

---

## Same code, in Reason

``` {.javascript}
let rec read_and_accumulate = accum => {
  let line = In_channel.input_line(In_channel.stdin);
  switch (line) {
  | None => accum
  | Some(x) => read_and_accumulate(accum +. Float.of_string(x))
  };
};

let () = printf("Total: %F\n", read_and_accumulate(0.));
```

::: notes

Here's the same OCaml code, but in the Reason syntax.

The point is, underneath, it is the same language and same semantics. So I'll use both Reason and OCaml interchangeably in this presentation, depending on what fits the context better.

:::

---

# What can we build with Reason/OCaml?

::: notes

So is it actually useful? This language. What can we build with it? Let me take you through some examples.

:::

---

## What can we build with Reason/OCaml?

### High-frequency trading software

&nbsp;

![](images/jane-street.png)

::: notes

When you start reading about OCaml, you'll often come across Jane Street. They are one of the largest production users of the language and they do billions of dollars worth of trading, all with software written in OCaml.

:::

---

## What can we build with Reason/OCaml?

### World's second largest crawler

&nbsp;

![](images/ahrefs.png)

::: notes

If you have done any SEO work, you might be familiar with Ahrefs. They crawl about 5 million pages every minute, and they have the second largest index just after Google. They use native OCaml for all the back-end infra and for the front-end web they use Reason.

:::

---

## What can we build with Reason/OCaml?

### Compilers

* First version of the Rust compiler
* Flow (typechecker for Javascript)
* Hack (Facebook's PHP compiler)

&nbsp;

::: notes

OCaml is also particularly nice to write compilers on - in fact anything that deals with a lot of tree manipulation is a great fit. Rust borrows many ideas from OCaml, and their first compiler was written in the language. Facebook is also a large user of OCaml internally.

5mins

:::

---

## What can we build with Reason/OCaml?

### Front-end web applications!

* BuckleScript compiles Reason/OCaml to Javascript

::: notes

Those were the traditional applications of OCaml. 

OCaml can also be used to build front-end web applications, and that's what this talk is about.

The regular OCaml compiler emits executable binary, but we want Javascript so it executes on the browser. So there is an OCaml compiler called BuckleScript that emits performant Javascript. And it lets us use any npm library in the OCaml code almost seamlessly.

:::

---

``` {.javascript}
if (MomentRe.Moment.isSameWithGranularity(
      MomentRe.momentNow(),
      MomentRe.moment("2020-04-01"),
      `day,
    )) {
  Js.log("It is the 1st of April!");
} else {
  Js.log("A dreary day");
};
```

::: notes

This Reason code here - it checks whether the current day is April 1st 2020,
and then shows a message.

It uses the momentjs Javascript library from npm. Now let's see how the BuckleScript output looks.

:::

---

``` {.javascript}
// Generated by BUCKLESCRIPT VERSION 5.0.6, PLEASE EDIT WITH CARE
'use strict';

var Moment = require("moment");
var MomentRe = require("bs-moment/src/MomentRe.js");

if (Moment().isSame(MomentRe.moment(undefined, "2020-04-01"), "day")) {
  console.log("It is the 1st of April!");
} else {
  console.log("A dreary day");
}

/*  Not a pure module */
```

::: notes

As you can see BuckleScript required the correct npm module and compiled everything to straightforward Javascript. 

:::

----

## Javascript vs Reason

* **Javascript**: `this`, variable hoisting, prototypes, ES6 classes, objects, mutations, _functions, modules_

* **Reason**: _functions, modules, types_

::: notes
Javascript however is a large language -- it has far too many concepts -- and that is obvious if you've participated in any Javascript interview. You can ask and be asked so many questions. There is the concept of `this`, there is prototypes and prototype inheritance chains which have their own rules, and there are also classes, objects, and mutation. It also has functions and higher-order functions.

Reason comparatively is a smaller language. It only has functions, modules, and types.  We don't, for example, concern ourselves with what `this` could be during runtime. In fact a Reason interview would be a rather unexciting event - there aren't that many quirks to the language to deal with.
:::

---

## Programming in Reason

Two principles:

1) Write pure functions
2) Get their types right

::: notes

The way we program Reason is to write pure functions and call them. That's it. If the types don't match, the compiler will tell us, so we can fix them.

How is that an improvement over Javascript? We could write Javascript programs made up of pure functions alone, with an outer shell to I/O. That's a great way to program.

But Reason guarantees something else:
:::

----

# Perfection

::: notes

"perfection".

Reason functions are "perfect" - what that means is that they do exactly what they need to do; nothing more; nothing less. And they work perfectly reliably, all the time, every time.

Let's try applying that notion to Javascript functions.

::: 

----

## An Imperfect Function

``` {.javascript}
let showNext = lastUser => {
  console.log("You will be user " + (lastUser.id + 1))
}

showNext({id: 16})
```

**_You will be user 17_**

::: notes

Consider this function `showNext` - it tells you what your user id could be, based on the last user in the system. 

The code is as simple as it can get. 

But does it work perfectly reliably all the time, every time?

Will it ever crash in production?

:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: null)
```

::: notes
What if `id` is null?
:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: null)
```

**_You will be user 1_**

::: notes
Thankfully that works. Our function is resilient to nulls.
:::

----

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: "193"})
```

::: notes
What if id was a string?
:::

----


## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({id: "193"})
```

**_You will be user 1931_**

::: notes
That's not what we expected. That's one problem with this function.
:::

---

## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({})
```

::: notes
Now what happens when the object is empty?
:::

----


## An Imperfect Function

``` {.text}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

``` {.javascript}
showNext({})
```

**_You will be user NaN_**

::: notes
This is also a wrong result. Another way the function is not perfect.
:::

----

## An Imperfect Function


``` {.javascript}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

let users = []
let lastUser = users[users.length - 1]

showNext(lastUser)
```

::: notes
We now have a list of users and we apply the last one to `showNext`. 
Unfortunately, the list is empty. What happens now?
:::

----

## An Imperfect Function



``` {.javascript}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

let users = []
let lastUser = users[users.length - 1]

showNext(lastUser)
```

**_Uncaught TypeError: Cannot read property 'id' of undefined_**

::: notes
The function actually crashes. 

This is a common occurence - we fetch a value from an array or an object -- and it doesn't exist -- so we get a null or an undefined, and then we pass that down to other functions.. and things crash in production. To figure out why, you now have to work backwards and trace the entire data-flow till we find where the data went wrong.
:::

----

## An Imperfect Function


``` {.javascript}
showNext()
showNext({id: "a"})
showNext({id: {}})
showNext(undefined)
showNext(null)
showNext(0)
showNext("a")
showNext([])
showNext([1])
showNext(a => a + 1)
```

::: notes
Our function is not "perfect". So let's count the number of ways our function breaks. There are, as you can see, quite a few.
:::

----

## An Imperfect Function


``` {.javascript}
let showNext = u => {
  console.log("You will be user " + (u.id + 1))
}

showNext(lastUser)

```

**_You will be user NaN_**

::: notes
What if the object was empty? That doesn't crash the function, but it gives us an invalid result. That's one way the function is not perfect.
:::

----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::

----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::


----

## An Imperfect Function


``` {.javascript}
```

::: notes
:::

----

## The cost of Drama


::: notes

Let's build a tiny invoicing program.
It is for a drama troupe.
They put two kinds of plays: Comedies and Tragedies.
:::



---

## First step

``` {.javascript}
switch (play.type) {
  case "tragedy":  
    return new TragedyCalculator(
      aPerformance, aPlay
    );
    
  case "comedy":
    thisAmount = 30000;
    if (perf.audience > 20) {
      thisAmount += 10000 + 500 * (perf.audience - 20);
    }
    thisAmount += 300 * perf.audience;
    break;
  default:
    throw new Error(`unknown type: ${play.type}`);
}
```


---

## Code example

``` {.javascript}
type type_ =
  | Tragedy
  | Comedy;

type play = {
  name: string,
  audience: int,
  type_,
};
```

